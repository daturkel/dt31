; R.a = data pointer
; R.b = instruction pointer
; R.c = current instruction
; R.d = scratch
; R.e = scratch
; R.f = scratch
    STRIN [0]  ; get program
    NEXT 0, R.a  ; find program end
    ADD R.a, 1  ; set memory start
    SUB R.b, 1  ; set instruction pointer to -1

loop:
    ADD R.b, 1  ; increment instruction pointer
    CP [R.b], R.c  ; get current instruction
    RJNE 3, R.c, '>'
    ADD R.a, 1  ; increment data pointer
    JMP loop
    RJNE 3, R.c, '<'
    SUB R.a, 1  ; decrement data pointer
    JMP loop
    RJNE 3, R.c, '+'
    ADD [R.a], 1  ; increment data
    JMP loop
    RJNE 3, R.c, '-'
    SUB [R.a], 1  ; decrement data
    JMP loop
    RJNE 3, R.c, '.'
    COUT [R.a]  ; output data
    JMP loop
    RJNE 3, R.c, ','
    CIN [R.a]  ; input data
    JMP loop
    RJNE 3, R.c, '['
    JEQ seek_right, [R.a], 0  ; if data is 0, jump to ]
    JMP loop
    RJNE 3, R.c, ']'
    JNE seek_left, [R.a], 0  ; if data is nonzero, jump to [
    JMP loop
    EXIT
; R.d = scratch
; R.e = scratch
; R.f = bracket counter

seek_right:
    CP 1, R.f  ; set bracket counter to 1

right_loop:
    ADD R.b, 1  ; move right 1 instruction
    RJEQ 3, [R.b], '['  ; if the character is [, call inc then loop
    RJEQ 3, [R.b], ']'  ; elif the character is ], call dec
    JMP right_loop  ; else loop
    CALL inc
    JMP right_loop
    CALL dec
    JNE right_loop, R.f, 0  ; if bracket counter isn't 0, loop, else ret
    RET

seek_left:
    CP -1, R.f  ; set bracket counter to -1

left_loop:
    SUB R.b, 1  ; move left 1 instruction
    RJEQ 3, [R.b], ']'  ; if the character is ], call dec then loop
    RJEQ 3, [R.b], '['  ; elif the character is [, call inc
    JMP left_loop  ; else loop
    CALL dec
    JMP left_loop
    CALL inc
    JNE left_loop, R.f, 0  ; if bracket counter isn't 0, loop, else ret
    RET

dec:
    SUB R.f, 1  ; decrement bracket counter
    RET

inc:
    ADD R.f, 1
    RET
